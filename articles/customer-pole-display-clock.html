
<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />


    <link rel="stylesheet" type="text/css" href="https://so1der.github.io/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
    href="https://so1der.github.io/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
          href="https://so1der.github.io/theme/pygments/monokai.min.css">



  <link rel="stylesheet" type="text/css" href="https://so1der.github.io/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://so1der.github.io/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://so1der.github.io/theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href="/static/custom.css">




  <link href="https://so1der.github.io/rss.xml" type="application/rss+xml" rel="alternate" title="so1der RSS">







 

<meta name="author" content="so1der" />
<meta name="description" content="DIY годинник з недорогого VFD дисплея покупця IKS-L-2x20" />
<meta name="keywords" content="diy, годинник">


  <meta property="og:site_name" content="so1der"/>
  <meta property="og:title" content="Годинник з VFD індикатора клієнта!"/>
  <meta property="og:description" content="DIY годинник з недорогого VFD дисплея покупця IKS-L-2x20"/>
  <meta property="og:locale" content="uk"/>
  <meta property="og:url" content="https://so1der.github.io/articles/customer-pole-display-clock.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2024-11-23 16:41:00+02:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://so1der.github.io/author/so1der.html">
  <meta property="article:section" content="YouTube"/>
  <meta property="article:tag" content="diy"/>
  <meta property="article:tag" content="годинник"/>
  <meta property="og:image" content="/logo.png">

  <title>so1der &ndash; Годинник з VFD індикатора клієнта!</title>


</head>
<body class="dark-theme">

<aside>
  <div>
    <a href="https://so1der.github.io/">
      <img src="/logo.png" alt="so1der" title="so1der">
    </a>

    <h1>
      <a href="https://so1der.github.io/">so1der</a>
    </h1>

    <p>Вітаю Вас на моєму особистому сайті!</p>


    <nav>
      <ul class="list">



          <li>
            <a target="_self" href="/articles/about.html#about" >Про мене</a>
          </li>
          <li>
            <a target="_self" href="/articles/website.html#website" >Про вебсайт</a>
          </li>
          <li>
            <a target="_self" href="/articles/contact.html#contact" >зв'язок</a>
          </li>
      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-github"
           href="https://github.com/so1der"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-youtube"
           href="https://www.youtube.com/@CtrlD-3v3"
           target="_blank">
          <i class="fa-brands fa-youtube"></i>
        </a>
      </li>
      <li>
        <a class="sc-mastodon"
rel="me"           href="https://soc.ua-fediland.de/@noaa_in_ukraine/"
           target="_blank">
          <i class="fa-brands fa-mastodon"></i>
        </a>
      </li>
      <li>
        <a class="sc-rss"
           href="/rss.xml"
           target="_blank">
          <i class="fa-solid fa-rss"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="https://so1der.github.io/">Головна</a>

  <a href="/archives.html">Архіви</a>
  <a href="/categories.html">Категорії</a>
  <a href="/tags.html">Теги</a>


  <a href="https://so1der.github.io/rss.xml">RSS</a>
</nav>

<article class="single">
  <header>
      
    <h1 id="customer-pole-display-clock">Годинник з VFD індикатора клієнта!</h1>
    <p>
      Опубліковано 23.11.2024, 16:41 в категорії <a href="https://so1der.github.io/category/youtube.html">YouTube</a>

    </p>
  </header>


  <div>
    <p><img alt="Індикатор клієнта" src="https://so1der.github.io/images/customer-pole-display-clock/cpd.png" title="Індикатор клієнта"></p>
<p>Думаю ви точно помічали, будучи в магазинах або супермаркетах, різноманітні дисплейчики на яких вам показують решту, назву товару, і усіляке таке. Це так званий "індикатор клієнта", спеціальний прилад який підключається до касового апарату, і касовий апарат на ньому відображає потрібну інформацію. В даній статті поглянемо на один з таких дисплеїв, розберемось що в нього всередині, і навіть підключимо до нього мікроконтролер та зробимо з нього годинник!</p>
<p><img alt="borgar" src="https://so1der.github.io/images/customer-pole-display-clock/ips.png" title="borgar"></p>
<p>Типів індикаторів клієнтів насправді немало. Це і світлодіодні семисегментні, і символьні LCD, вакуумно-люмінесцентні, і навіть повноцінні графічні IPS, LCD, чи що вони туди там ставлять. Світлодіодні семисегментні індикатори зараз і без того дуже поширені, і цікавіше та легше буде самому зібрати те що треба, а не використовувати готовий пристрій, тому їх відкидаємо. Символьні LCD зараз теж можно запросто купити в будь якому магазині пов'язаному з мікроконтролерами. Графічні вже цікавіше, але коштувати вони будуть дуже багато, та і вони відносно нові, тому магазини не поспішають їх позбавлятись. А от вакуумно-люмінесцентні - найцікавіший варіант, і зараз я поясню чому.</p>
<p><img alt="Макро фото анодів" src="https://so1der.github.io/images/customer-pole-display-clock/macro-vfd.jpg" title="Макро фото анодів"></p>
<p>По перше, ці дисплейчики вже доволі старі, як і сама технологія вакуумної люмінесценції, тому їх можна знайти задешево на тому ж OLX. По друге - вони доволі круто і ЛАМПОВО виглядають (ну це типу буквально вакуумна лампа, зрозуміли да). Вони мають приємне зелене світіння. По третє - якщо подивитись скільки такі дисплейчики коштують на AliExpress або Ebay, то задешево придбати собі такий у нас виглядає досить привабливо. Але є у таких дисплейчиків і проблема - їх доволі складно живити та керувати ними. Справа в тому що ці дисплеї потребують дві доволі нестандартні напруги. </p>
<p>По перше, напруга для нитки розжарювання -вона доволі маленька, у маленьких індикаторів - в районі вольта, і в ідеалі вона повинна бути змінною, інакше дисплей може нерівномірно світитись. Більш того - змінною не відносно нуля, а відносно якогось вищого потенціалу.</p>
<p>Ну і по друге - напруга на аноди та сітки, ця напруга доволі велика, від 20 до інколи навіть 50В. Тобто що одна що інша напруга разюче відрізняється від мікроконтролерних 5V або 3.3V.</p>
<p><img alt="Дисплей ІКС-Л-2*20 на OLX" src="https://so1der.github.io/images/customer-pole-display-clock/olx.jpg" title="Дисплей ІКС-Л-2*20 на OLX"></p>
<p>Тому й вигідно брати готовий пристрій - індикатор клієнта, там все вже зробили за нас, живлення, керування, нам залишається посилати дані на дисплей. Наразі на ОЛХ дуже поширені дисплеї від компанії <a href="https://www.ics-tech.kiev.ua/">ІКС Техно</a>. В них є дисплей <a href="https://www.ics-tech.kiev.ua/prodsphp/IKS-L-2X20.php">ІКС-Л-2*20</a>. Важливо не сплутати його з <a href="https://www.ics-tech.kiev.ua/prodsphp/IKS-RKI-2X20.php">ІКС-РКІ-2*20</a>, бо літери всередині показують тип дисплею.</p>
<p>Л - вакумно-люмінесцентний
РКІ - відповідно, LCD, тобто рідкокристалічний.</p>
<p>Індикатор клієнту має ніжку та дріт RJ-11 для підключення до касового апарату.
Ось звісно і зворотня сторона того що вони старі. Стан корпусу в цього екземпляру такий собі.</p>
<p><img alt="Численні подряпини на корпусі дисплея" src="https://so1der.github.io/images/customer-pole-display-clock/scratches.jpg" title="Численні подряпини на корпусі дисплея"></p>
<p>Давайте подивимось що всередині. Розкрутивши корпус нас зустрічає сам дисплей. Відкрутивши ще 4 саморізи добираємось до зворотньої сторони плати, де і знаходиться все що нас цікавить. Я прибрав дріт з RJ-11, так як він більше не знадобиться. </p>
<p><img alt="Розібраний дисплей" src="https://so1der.github.io/images/customer-pole-display-clock/teardown.jpg" title="Розібраний дисплей"></p>
<p>Роздивимось кожний блок по порядку. </p>
<h2>Живлення</h2>
<p><img alt="MC34063A та захисний діод" src="https://so1der.github.io/images/customer-pole-display-clock/mc34063a.jpg" title="MC34063A та захисний діод"></p>
<p>Спочатку йдуть 2 вузли живлення. Вони являють собою звичайні DC-DC перетворювачі на мікросхемі <strong>MC34063A</strong>. Один робить 5V для живлення мікроконтролеру та низьковольтної логіки, інший робить 39V для живлення анодів та сіток VFD індикатора. Наскільки я розумію, касові апарати можуть видавати доволі широкий спектр напруг, тому тут і зробили окремий перетворювач на 5В, а не просто живлення від 5В блочку. Також до речі тут є діод від переполюсовки живлення, який вже врятував мені дисплей одного разу.</p>
<h2>Логіка</h2>
<p><img alt="ATmega8A" src="https://so1der.github.io/images/customer-pole-display-clock/atmega8a.jpg" title="ATmega8A"></p>
<p>Далі йде сам мікроконтролер. В даному випадку це <strong>ATmega8A</strong>, яка тактується кварцевим резонатором на 16 МГц. Мікроконтролер окрім обробки інформації робить ще 2 важливі речі. По перше, він через транзистор дає свого роду дозвільний сигнал на генерацію анодної напруги. По друге - на частоті <strong>200 кГц</strong> він через два транзистори розкачує дросель, або імпульсний трансформатор, і тим самим генерує змінну напругу для нитки розжарювання дисплею. </p>
<p><img alt="200 кГц сигнал на базі одного з транзисторів" src="https://so1der.github.io/images/customer-pole-display-clock/200khz.jpg" title="200 кГц сигнал на базі одного з транзисторів">
<img alt="Меандр на базі одного з транзисторів" src="https://so1der.github.io/images/customer-pole-display-clock/square-wave-signal.jpg" title="Меандр на базі одного з транзисторів"></p>
<p>До речі мікроконтролер тут залочений (заблоковано доступ до програмної пам'яті для запису/зчитування через fuse-біти), і його неможливо ані зчитати, ані навіть стерти без спеціального <a href="https://ericdraken.com/hvsp/">HVSP програматора</a> або <a href="https://github.com/SukkoPera/avr-fusebit-doctor">FuseBit Doctor-а</a>. Тому його доведеться перепаювати якщо ви захочете залити туди кастомну прошивку.</p>
<p>А ви повірте, захочете, бо вона дає можливість як мінімум малювати 8 кастомних символів. До речі я писав бібліотеку для роботи з драйвером наявним на платі, переглянути її можна за <a href="https://github.com/so1der/PT6314">ось цим посиланням</a>.</p>
<p><img alt="Приклад використання кастомних символів для малювання великих цифр" src="https://so1der.github.io/images/customer-pole-display-clock/custom-chars.jpg" title="Приклад використання кастомних символів для малювання великих цифр"></p>
<p>До речі, пам'ятаєте про діод від переполюсовки? Одного разу я випадково все ж таки переполюсовав живлення, прям на цьому діоді. Напруга дуже сильно просіла, діод дуже сильно нагрівся, від плати від нагріву ледь не відвалилась доріжка, і все в такому дусі. Діод таки врятував дисплей.</p>
<p>Але що цікаво - після цього мікроконтролер почав себе трішки дивно вести. Спочатку я подумав що попросту вбив мікроконтролер, але потім я побачив деяку закономірність - він працював, але не так як слід, повільніше, наче хтось забув виставити fuse-біти, які відповідають за вибір джерела тактування.  Тому я спробував зчитати ці фьюзи, і побачив що дійсно, фьюзи збились! Тому дисплей і працював дивно. Але найголовніше - мікроконтролер розлочився! 
На жаль я тоді навіть не подумав про те щоб зчитати оригінальну прошивку (навіть не глянув, чи знявся fuse на читання, чи ні), бо був настільки радий що збився fuse на стирання, і тому швиденько очистив мікроконтролер, щоб залити туди свою прошивку. А можливо це був єдиний в житті спосіб зчитати цю залоченну прошивку. Думки про це не дають мені спокою і дотепер...</p>
<h2>Драйвер VFD</h2>
<p><img alt="PT6314-009" src="https://so1der.github.io/images/customer-pole-display-clock/pt6314.jpg" title="PT6314-009"></p>
<p>Далі йде найбільша на платі мікросхема - той самий драйвер, <strong>PT6314</strong>. Про нього мало що можна сказати, звичайний драйвер, який працює практично так само як і китайські LCD дисплейчики, в яких стоїть драйвер <strong>HD44780</strong>. Має 8 кастомних символів та цілу таблицю предзаписаних, може керуватись як послідовно так і паралельно, щоправда на цій платі доступний лише послідовний порт керування. Паралельні - підтягнути до землі, тому без ювелірної роботи з підняття ніжок, використовувати паралельний порт не вийде.  </p>
<p>На жаль більшість функцій цього драйвера недоступна (очищення екрану, регулювання яскравості, кастомні символи), через залоченний мікроконтролер, і прошивку, в якій це все не реалізували. Єдине що можу сказати цікавого - в цих драйверів є певна кількість модифікацій, в яких додатково до англійської абетки ще є наприклад японська, європейська, або взагалі якісь спеціальні символи. В нашому ж випадку, записана кирилиця, з українськими літерами! Для китайських дисплеїв які зараз можна купити це взагалі рідкість, тому цей дисплей ще й в цьому плані унікальний. Про дану модифікацію немає ні слова в <a href="/files/customer-pole-display-clock/PT6314.pdf">даташиті</a>, мабуть це було якесь спеціальне замовлення компанією ІКС Техно, адже на деяких сайтах можна знайти <a href="https://www.importgenius.com/ukraine/suppliers/huangshan-hexin-trading-co-ltd">записи про імпорт даних мікросхем даною компанією</a>. Тому єдине джерело символьної таблиці для цього дисплею, це його <a href="/files/customer-pole-display-clock/IKC-L-2-20_pas.pdf">паспорт</a>.</p>
<h2>RS-232</h2>
<p><img alt="ST232C" src="https://so1der.github.io/images/customer-pole-display-clock/st232.jpg" title="ST232C"></p>
<p>Ну і на останок, мікросхема <strong>ST232C</strong>. Вона потрібна щоб перетворювати сигнали протоколу RS232 в сумісний для мікроконтролеру UART. Про неї багато говорити не будемо, бо вона взагалі нам заважає, тому треба її випаяти. Можливо можна і не випаювати, але краще все таки це зробити, це точно додасть стабільності передачі даних, так як на UART шині не буде висіти нічого зайвого. Я зробив це за допомогою паяльного фену.</p>
<p><img alt="Демонтована ST232C" src="https://so1der.github.io/images/customer-pole-display-clock/desoldered-st.jpg" title="Демонтована ST232C"></p>
<h2>Виводимо дані</h2>
<p>Ініціалізацію драйвера  і керування живленням наявний мікроконтролер зробить за нас, достатньо просто посилати на нього дані. Для цього я підпаяв дріт на місце де колись була ніжка RX раніше відпаяної мікросхеми. </p>
<p><img alt="Дротик для передачі даних" src="https://so1der.github.io/images/customer-pole-display-clock/wire.jpg" title="Дротик для передачі даних"></p>
<p>Після цього я взяв <strong>ESP8266</strong> та написав для неї код. Насправді він мало чим відрізняється від дефолтного Hello World по UART, за виключенням лише того, що  після подачі живлення ESP8266 має почекати секунду, щоб дисплей встиг ініціалізуватись, якщо живлення на дисплей та ESP8266 було подано одночасно.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Arduino.h&gt;</span>

<span class="c1">// Встановлення курсору:</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">setCursorVFD</span><span class="p">(</span><span class="n">byte</span><span class="w"> </span><span class="n">place</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//                        EOT   SOH     P          ETB</span>
<span class="w">    </span><span class="n">byte</span><span class="w"> </span><span class="n">cursor_position</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x04</span><span class="p">,</span><span class="w"> </span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x50</span><span class="p">,</span><span class="w"> </span><span class="n">place</span><span class="p">,</span><span class="w"> </span><span class="mh">0x17</span><span class="p">};</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">cursor_position</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">cursor_position</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Очистка дисплею</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">clearVFD</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">setCursorVFD</span><span class="p">(</span><span class="mh">0x31</span><span class="p">);</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;                                        &quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">setCursorVFD</span><span class="p">(</span><span class="mh">0x31</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">(){</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
<span class="w">    </span><span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
<span class="w">    </span><span class="n">clearVFD</span><span class="p">();</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello World!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">(){</span>

<span class="p">}</span>
</code></pre></div>

<p>Як бачите, функція очищення дисплею просто шедевральна! Для мене досі загадка, чому ІКС-Техно її не реалізували в прошивці (в паспорті її немає, + я намагався перебирати команди - не знайшов). Скоріше за все це якась умовність роботи касових апаратів. Мабуть вони не посилають команду на очищення, а просто посилають текст, який перезаписує все зайве пробілами, чи шось таке.</p>
<p>Раніше припаяний до дисплею дріт йде до ESP8266 на ніжку TX, також треба об'єднати землю ESP8266 з землею дисплея, і подати живлення на дисплей. Я подав 12В на раніше згаданий діод, бо до нього доволі зручно чіплятись крокодилами, після чого подав живлення на мікроконтролер.</p>
<p><img alt="Hello Wordl!" src="https://so1der.github.io/images/customer-pole-display-clock/hello-world.jpg" title="Hello Wordl!"></p>
<p>Чудово. А тепер давайте державною. </p>
<div class="highlight"><pre><span></span><code><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Привіт Ютуб!&quot;</span><span class="p">);</span>
</code></pre></div>

<p><img alt="йой" src="https://so1der.github.io/images/customer-pole-display-clock/fail.jpg" title="йой"></p>
<p>Іііі, щось пішло не так D:</p>
<p>Справа в тому, що функція <code>Serial.print()</code> бере текст, і кодує його в певну послідовність байтів. Скоріше за все компілятор робить це кодуючи символи за UTF-8. А в символьній таблиці цього дисплею ми маємо комбінацію з UTF-8 та CP866, тому англійські символи виводяться нормально, а українська - ні. Можливо є якийсь спосіб це обійти, але легше просто через <code>Serial.write()</code> подавати потрібний байт, та і все. Для облегшення цього процесу я написав невеличкий скрипт на Python, який конвертує строку в послідовність байтів, яку й треба використати. В цілому він працює, але в кодуванні CP866 чомусь немає літери І, тому на ній скрипт ламається, тому я заміняю її на англійську. Це трішки дивно, адже літери Ї та Є там присутні, ну але не про це. </p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">UTF8_to_hex_CP866</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">encoded_bytes</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;cp866&#39;</span><span class="p">)</span>
    <span class="n">hex_values</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;0x</span><span class="si">{</span><span class="n">byte</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">encoded_bytes</span><span class="p">]</span>
    <span class="n">formatted_hex</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hex_values</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
    <span class="k">return</span> <span class="n">formatted_hex</span>


<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s2">&quot;Input string: &quot;</span><span class="p">)</span>
    <span class="n">user_input</span> <span class="o">=</span> <span class="n">user_input</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;і&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;І&#39;</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">UTF8_to_hex_CP866</span><span class="p">(</span><span class="n">user_input</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>

<p>Давайте спробуємо конвертувати якусь строку, і вивести її на дисплей.</p>
<div class="highlight"><pre><span></span><code><span class="gp">ctl@pop-os:~$ </span>python<span class="w"> </span>CP866.py<span class="w"> </span>
<span class="go">Input string: Привіт Ютуб!</span>
<span class="go">{0x8f, 0xe0, 0xa8, 0xa2, 0x69, 0xe2, 0x20, 0x9e, 0xe2, 0xe3, 0xa1, 0x21}</span>
</code></pre></div>

<p>Трішки модифікуємо вивід символів:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">setup</span><span class="p">(){</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
<span class="w">    </span><span class="n">delay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
<span class="w">    </span><span class="n">clearVFD</span><span class="p">();</span>
<span class="w">    </span><span class="n">byte</span><span class="w"> </span><span class="n">message</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0x8f</span><span class="p">,</span><span class="w"> </span><span class="mh">0xe0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xa8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xa2</span><span class="p">,</span><span class="w"> </span><span class="mh">0x69</span><span class="p">,</span><span class="w"> </span><span class="mh">0xe2</span><span class="p">,</span><span class="w"> </span><span class="mh">0x20</span><span class="p">,</span><span class="w"> </span><span class="mh">0x9e</span><span class="p">,</span><span class="w"> </span><span class="mh">0xe2</span><span class="p">,</span><span class="w"> </span><span class="mh">0xe3</span><span class="p">,</span><span class="w"> </span><span class="mh">0xa1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x21</span><span class="p">};</span>
<span class="w">    </span><span class="n">Serial</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p><img alt="Привіт Ютуб! Так стоп, ми ж не на ютубі..." src="https://so1der.github.io/images/customer-pole-display-clock/hello-youtube.jpg" title="Привіт Ютуб! Так стоп, ми ж не на ютубі..."></p>
<h2>Годинник</h2>
<p>Чудово! Тепер, вміючи керувати дисплеєм, та маючи WiFi мікроконтролер, можна зробити безліч цікавих проєктів. Наприклад крутий годинник! Насправді в мене вже давненько є такий годинник, на такому дисплеї, але він доволі сирий, і був заточений чисто під мене. Тому я модифікував прошивку І залив її на GitHub. Ось <a href="https://github.com/so1der/IKS_L_2x20_clock">посилання</a></p>
<p><img alt="З Новим Роком :D" src="https://so1der.github.io/images/customer-pole-display-clock/new-year.jpg" title="З Новим Роком :D"></p>
<p>Не дивлячись на те, що більшість коду вже було написано, це виявилось доволі складним процесом, бо він включав в себе 2 речі в яких я майже нічого не знаю - HTML/CSS, та JavaScript. І якщо проблема з HTML/CSS вирішилась дуже легко - я просто попросив свою круту подругу написати мені код, то от в JavaScript-і та різних WEB аспектах - довелось розбиратись.</p>
<p>Коли годинник вмикається, він починає шукати збережену в пам'яті мережу WiFi. Якщо він її не знайшов, він підіймає власну мережу, тобто так званий Access Point і сповіщає про це користувача - написавши назву мережі, пароль, та IP адресу за якою треба підключитись. </p>
<p><img alt="Параметри AP" src="https://so1der.github.io/images/customer-pole-display-clock/ap-mode.jpg" title="Параметри AP"></p>
<p>Користувач з телефону або ноутбуку підключається до цієї мережі, вводить IP в адресну строку браузера, і потрапляє на сторінку налаштування годиннику. В даному випадку є 2 шляхи - можна просто синхронізувати годинник з телефоном або ноутбуком натискаючи відповідну кнопку, і все. Але з часом буде рости похибка, бо китайський RTC модуль не ідеальний, як і все в цьому світі. </p>
<p><img alt="WEB інтерфейс годинника" src="https://so1der.github.io/images/customer-pole-display-clock/web.jpg" title="WEB інтерфейс годинника"></p>
<p>Іншим ж шляхом буде ввести дані від своєї WiFi мережі, і тоді годинник зможе підключитись до неї, і через інтернет раз на день брати точний час з NTP серверу. До речі NTP сервер теж можна налаштувати, для цього є відповідне поле. Наприклад в мене, на моєму роутері з OpenWrt, піднятий власний NTP сервер, який працює навіть коли немає інтернету, тому я використовую його (просто вводжу локальний IP роутера - 192.168.1.1). За замовчуванням стоїть один з серверів time.in.ua</p>
<p>Так як NTP сервер повертає час у форматі UTC 0, тобто так званий нульовий часовий пояс, необхідно вручну обирати потрібний часовий пояс. Я не вигадав як це нормально автоматизувати, коли в нас змінюється часовий пояс, тому якщо в когось є ідеї - прошу вас до репозиторію, надсилайте пулл реквести.</p>
<p>До речі якщо годинник після запуску зміг підключитись до WiFi мережі, то він напише свою IP адресу яку йому видає роутер, і за нею теж можна потрапити до налаштувань годиннику, щоб, наприклад, корегувати температуру. </p>
<p>До речі я ж зовсім нічого не розповів за датчик температури. Я поставив звичайний цифровий датчик Dallas 18B20, він підключений до піну D4. Дисплей помітно так нагрівається при роботі, тому краще тримати датчик подалі, інакше дисплей буде вносити помітну таку похибку в значення температури.</p>
<p>Зібрати все треба за цією схемою - під'єднати RTC модуль DS1307, датчик температури, завести живлення, і годинник готовий.</p>
<p><img alt="Схема" src="https://so1der.github.io/images/customer-pole-display-clock/schematic.jpg" title="Схема"></p>
<p>А на цьому в мене все!</p>
<h2>Post Scriptum</h2>
<p>Це текстова версія відео з мого YouTube каналу. Відео можна переглянути <a href="https://www.youtube.com/watch?v=WfuQ5s6Yd70">за посиланням</a></p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://so1der.github.io/tag/diy.html">diy</a>
      <a href="https://so1der.github.io/tag/godinnik.html">годинник</a>
    </p>
  </div>







</article>

<footer>
<p>&copy; 2025 </p>
<p>
Сайт створено за допомогою <a href="http://getpelican.com" target="_blank">Pelican</a> використовуючи <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> тему
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " so1der ",
  "url" : "https://so1der.github.io",
  "image": "/logo.png",
  "description": ""
}
</script>
</body>
</html>